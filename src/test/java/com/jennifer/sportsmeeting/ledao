TODO：一面：线上笔试：
java 基础：
    1.== 和 equals 的区别是什么？
        == 引用类型；比较的地址
        equals 基本类型 ；比较的是值

    2.集合类(容器)？
         参考Q.txt
         ConcurrentHashMap的实现？
              答：参考资料

    3.反射
        反射是什么？答：是在运行时根据指定的类名获得类的信息。
        反射作用是什么？答：利用反射动态的编译创建对象
        interface fruit{
            public abstract void eat();
        }
     1----------------------------------------------------
     1   class Apple implements fruit{
     1       public void eat(){
     1           System.out.println("Apple");
     1       }
     1   }
     1
     1   class Orange implements fruit{
     1       public void eat(){
     1           System.out.println("Orange");
     1       }
     1   }
     1__________________________________________________
       // 构造工厂类
       // 也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了
        class Factory{
            public static fruit getInstance(String fruitName){
                fruit f=null;
                if("Apple".equals(fruitName)){
                    f=new Apple();
                }
                if("Orange".equals(fruitName)){
                    f=new Orange();
                }
                return f;
            }
        }
        class hello{
            public static void main(String[] a){
                fruit f=Factory.getInstance("Orange");
                f.eat();
            }
        }
       ------------------------------------------------------------
       //反射机制优越性的体现：
        class Factory{
            public static fruit getInstance(String ClassName){
                fruit f=null;
                try{
                    f=(fruit)Class.forName(ClassName).newInstance();
                }catch (Exception e) {
                    e.printStackTrace();
                }
                return f;
            }
        }
        class hello{
            public static void main(String[] a){
                fruit f=Factory.getInstance("Reflect.Apple");
                if(f!=null){
                    f.eat();
                }
            }
        }
        ___________________________________________________________________

    4.多线程基础？
           线程有哪些状态？
               答：线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。
               创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。
               就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。
               运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。
               阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。
               死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪
           wait,notify？
               wait()方法是什么？答：当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池。同时释放对象的机锁。使得
                               其他线程池能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。
               notify与notifyAll有什么区别？
                                答：线程调用notify，线程便处于对象的等待池中，等待池中的线程不会去竞争对象的锁。
                                   线程调用notifyAll,被唤醒的线程进入对象的锁池中，锁池中线程会去竞争对象的锁。
                                   也就是说，调用notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象的等待池内所有
                                   线程移动到锁池，等待锁竞争。
           synchronized 底层实现原理？
               答：synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。
                 Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：
                 普通同步方法，锁是当前实例对象
                 静态同步方法，锁是当前类的class对象
                 同步方法块，锁是括号里面的对象
spring框架：
    springAop原理?
        Aop是什么？答：是面向切面编程。纵向代码横向解决的思路。如：过滤器
                    aop实现技术有：SpringAOP和AspectJ
                    SpringAOP:采用动态代理。它提供了对JDK动态代理的支持以及CGLib的支持。
                        JDK动态代理：只能为接口创建动态代理的实例。而不能对类创建动态代理需要获得被目标类的接口信息（应用Java的反射技术），
                            生成一个实现了代理接口的动态代理类（字节码），再通过反射机制获得动态代理类的构造函数，利用构造函数生成动态代理类的实例对象，
                            在调用具体方法前调用invokeHandler方法来处理。
                        CGLib动态代理：需要依赖asm包，把被代理对象类的class文件加载进来，修改其字节码生成子类。
                    AspectJ的底层技术是静态代理，即用一种AspectJ支持的特定语言编写切面。
                           通过一个命令来编译，生成一个新的代理类，该代理类增强了业务类，这是在编译时增强，
                           相对于下面说的运行时增强，编译时增强的性能更好。


数据结构：
    1.基本的数据结构
        a.顺序线性表和链表的区别？
            线性表是什么？答：是最基本、最简单、也是最常用的一种数据结构。
                           结构：除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。
                           关系是一对一，呈线性关系。
                           存储方式有2种：顺序结构存储，链式结构存储。
                           基本操作是：插入，删除，查找
                           线性表是具有相同数据类型的n(n>=0)个数据元素的有限序列，通常记为：
                           (a1,a2,a3,a4……an) 其中n为表长；当n为0时，称为空表。
            链表是什么？答：是一种物理存储单元上非连续、非顺序的存储结构。
                           结构：有一系列结点（元素）组成，结点可动态生成
                           每个结点包括2部分：存储数据元素的数据域(内存空间)和指针域
                           操作：不必按顺序插入，可达到O(1)复杂度
                           有：单链表、双链表、单向循环链表、双向循环链表
            链表与数组的区别？答：数组：使用一块连续的内存空间地址去存放数据。对已经定义好的数组，不能增删。需要另辟一块内存空间。
                               链表：使用多个不连续的内存空间去存储数据。增删方便，节省内存资源。
            线性表、顺序表、链表、数组的区别与联系？
                           答：c中，数组与线性表的区别：数组长度可变。线性表长度动态可变。
                           逻辑结构：是对操作对象的数学描述，描述的是数据元素之间的逻辑关系。如：线性结构、树形结构、图状结构、网状结构
                           物理结构：又是存储结构，是数据结构在计算机中的表示。如：数组，指针
                           线性表：是逻辑结构中的线性结构。包括线性表，链表。
                           顺序表：是线性表的一种，存储结构（数据结构）是连续的。用数组来实现。
                           链表：是线性表中的一种，存储结构不连续（指针实现），但除了静态链表连续（数组实现）之外


        b.二叉树：
             二叉树是什么？答：是每个节点最多只有2个分支的树结构。（2^K-1）
             分支被称为：左子树、右子树
             顺序：具有左右次序。不能任意颠倒。
             结点总数=2^K-1
             用Java实现二叉树？


        c.图的遍：
             图是什么？图的结构比较复杂，任意两个顶点之间都可能存在关系（边），无法通过存储位置表示这种任意的逻辑关系



设计模式：
    1.常用的设计模式和自己有写过哪些设计模式？
        答：常用的设计模式有：工厂模式
             单例模式：
             /**
              * 单例模式
              */
             public class Test {
                 private static Test test = new Test();
                 private  Test(){}
                 public static Test getInstance(){
                     return test;
                 }
             }

            装饰者模式：对已有的业务逻辑进一步封装，使其增加额外的功能。如IO流
            /**
             * 装饰者模式
             */
            public class Test {
                public static void main(String[] args) {
                    Food food = new Bread(new Pig(new Food("豪大大")));
                    System.out.println(food.make());//豪大大猪排面包
                }
            }
            public class Food {
                private String food_name;
                public Food(){}
                public Food(String food_name) {
                    this.food_name = food_name;
                }
                public String make(){
                    return food_name;
                }
            }
            public class Pig extends Food {
                private Food basic_food;

                public Pig (Food basic_food){
                    this.basic_food = basic_food;
                }
                public String make(){
                    return basic_food.make()+"猪排";
                }
            }

            public class Bread extends Food {
                private Food basic_food;
                public Bread(Food basic_food) {
                    this.basic_food = basic_food;
                }
                public String make(){
                    return basic_food.make()+"面包";
                }
            }

数据库：


计算机网络：
    1.Http协议?

TODO：二面：线上笔试：

操作系统一些原理,编译,java的虚拟机,对于java三大特性的理解以及设计模式的理解,更注重的是对知识的理解

